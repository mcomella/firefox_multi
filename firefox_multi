#!/usr/bin/env python
# TODO: Check .parentlock? How does that affect the lock system?

# This script will search the current users ~/.mozilla/firefox/profiles.ini for
# profiles with "sync" in the name (case sensitive) and attempt to open one of
# them on the current screen. If a profile is already open on the current
# screen, a new window from that profile will open on the current screen. Due to
# this last quirk, it is recommended to have at least one more profile available
# than the user expects to have open at a time.

# This script will also attempt to recover crashed profiles by looking at the
# $PROFILE_DIR/lock symlink and the address it points to. If the firefox process
# is not running at this address, the lock file is removed, and the profile is
# recovered. If the address is remote, the remote machine will be SSHed into.

# Any arguments with be passed to the spawned firefox instance through the
# typical firefox start script.

from os import execl, readlink
import ConfigParser, os.path, pickle, re, socket, subprocess, sys

PROGRAM_PATH = os.path.abspath(sys.argv[0])
SHELL_PATH = '/bin/bash'
FIREFOX_BASENAME = 'firefox'
FIREFOX_PATH = '/contrib/bin/' + FIREFOX_BASENAME
PROFILE_DIR = os.path.expanduser('~') + '/.mozilla/firefox'
PROFILE_INI = PROFILE_DIR + '/profiles.ini'

# Options for firefox process checks on remote hosts.
SSH_CONNECT_TIMEOUT = 2 # In seconds.
SSH_OPT = '"ConnectTimeout ' + str(SSH_CONNECT_TIMEOUT) + '"'

# The lock is a symlink pointing to the active machine ip & pid.
# Ex: 10.116.72.90:+30681
LOCK_SYMLINK_REGEX = '([0-9.]+):\+([0-9])$';

# Strings returned from the script in SSH mode to determine process status.
SSH_FF_RUNNING = 'firefox via_ssh: running'
SSH_FF_STOPPED = 'firefox via_ssh: stopped'

# TODO: Getting the IP this way may be fragile as per the official python docs.
LOCAL_IP = socket.gethostbyname(socket.gethostname())

# Finds profiles that are synced (contain 'sync' in their name) and returns them
# as an array of {'name', 'abs_path'} dicts.
def find_synced_profiles(filepath):
    config = ConfigParser.RawConfigParser()
    config.read(filepath)

    # Iterate over profiles. If filepath DNE, config.sections will have a len of
    # zero, and the empty array will be returned.
    synced_profiles = []
    for section in config.sections():
        if 'Profile' in section:
            name = config.get(section, 'Name')
            if 'sync' in name:
                path = config.get(section, 'Path')
                relative = config.getboolean(section, 'IsRelative')
                if relative:
                    path = PROFILE_DIR + '/' + path

                prof = {
                    'name': name,
                    'abs_path': path
                }
                synced_profiles.append(prof)
    return synced_profiles

# Finds profiles which are not currently being used from the given array of
# {'name', 'abs_path'} dicts. Returns these inactive profile dicts in an array.
def find_inactive_profiles(synced_profiles):
    inactive_profiles = [] # [ {'name', 'abs_path'} ]
    active_profiles = [] # [ {'name', 'abs_path', 'ip', 'pid'} ]
    for prof in synced_profiles:
        prof_ip, prof_pid = get_lock_proc_info(prof)
        if prof_ip is None: # When there is no ip (i.e. an inactive profile).
            inactive_profiles.append(prof)
        else:
            prof['ip'], prof['pid'] = prof_ip, prof_pid
            active_profiles.append(prof)

    if len(inactive_profiles) is 0:
        print 'Attempting to recover crashed profiles...'
        for prof in active_profiles:
            unlocked = attempt_to_recover_profile(prof)
            if unlocked is True:
                inactive_profiles.append(prof)
                break # Only recover one for time constraints.
    return inactive_profiles

# Returns a tuple with the active profile's machine ip and Firefox's pid
# (prof_ip, prof_pid). Returns (None, None) if the lock DNE or the lock's
# symlink format is not recognized. Additionally prints an error message in the
# latter case as this should not happen under normal usage. Input is a profile:
# {'abs_path'}.
def get_lock_proc_info(prof):
    try:
        info_str = os.readlink(prof['abs_path'] + '/lock')
    except OSError:
        # Thrown on os.readlink() if the given path is not a link (i.e. DNE).
        return (None, None)
    else:
        m = re.match(LOCK_SYMLINK_REGEX, info_str)
        if m is None:
            sys.stderr.write('get_lock_prof_info(): The link on profile "' +
                    prof['name'] + '" does not have a recognizable format. '
                    'This could be a problem with the script regex, or the '
                    'lock file may have been manipulated incorrectly. Please '
                    'manually review these items.')
            return (None, None)
        return (m.group(1), m.group(2)) # ip, pid

# Attempts to recover a profile by checking if a Firefox process exists at the
# specified machine and pid, and if not, deletes the lock file and returns True.
# Returns False otherwise. Input is an active profile: {'name', 'abs_path',
# 'ip', 'pid'}.
def attempt_to_recover_profile(prof):
    if firefox_is_running(prof): return False
    remove_lock(prof)
    return True

# Returns True if the firefox process is running from the given profile. Returns
# False otherwise. If the process is located on another machine, it will SSH to
# return the appropriate result; assumes True if there is an error. Input is a
# profile of {'name', 'abs_path', 'ip', 'pid'} and a boolean, via_ssh, True if
# this function is called in SSH mode.
def firefox_is_running(prof, via_ssh=False):
    if prof['ip'] is LOCAL_IP: # Firefox is running on localhost.
        try:
            with open('/proc/' + prof['pid'] + '/cmdline', 'r') as f:
                cmdline = f.read()
                if FIREFOX_BASENAME in cmdline: return True # Still active.
        except IOError: # File DNE: process is dead.
            pass
        return False

    else: # Firefox is running on a remote host.
        if via_ssh:
            sys.stderr.write('firefox_is_running(): SSH has accessed the wrong '
                    'machine (expected: ' + prof['ip'] + '; actual: ' +
                    LOCAL_IP + '). This should not happen.')
            # Firefox may not be running, but we're not on the correct machine
            # so we can't tell the difference. Assume that it's running so the
            # lock file is not deleted.
            return True

        # SSH into the remote host.
        proc = subprocess.Popen(['ssh', '-o', SSH_OPT, prof['ip'],
                PROGRAM_PATH, 'via_ssh', pickle.dumps(prof)], bufsize=-1,
                stdout=subprocess.PIPE)
        # stderr prints to stderr by default.
        stdout, stderr = ssh_proc.communicate() # Blocks until process ends.
        if SSH_FF_STOPPED in stdout: return False
        return True

# Removes the lock from the given profile. Input is a profile: {'abs_path'}.
def remove_lock(prof):
    prof_lock_path = prof['abs_path'] + '/lock'
    try:
        os.unlink(prof_lock_path)
    except OSError: # File DNE.
        # The lock is already gone so the profile is (presumably) safe to use.
        pass
    else:
        print 'Unlinked ' + prof_lock_path + '.'

# SSH mode: Checks if firefox is running on the current machine based upon the
# given profile information and returns that info. Expects args of the form:
#     cmd_path via_ssh prof
# where cmd_path = the executable path of this script
#       via_ssh = the string literal, 'via_ssh'
#       prof = a serialized profile of {`name`, `abs_path`, `ip`, `pid`}
if len(sys.argv) > 1 and sys.argv[1] is 'via_ssh':
    if len(sys.argv) is not 3:
        sys.exit('SSH mode: Expected cmd_path via_ssh prof.')
    prof = pickle.loads(sys.argv[2])
    if firefox_is_running(prof, via_ssh=True): print SSH_FF_RUNNING
    else: print SSH_FF_STOPPED
    sys.exit()

# User-started mode: Finds an inactive profile and launches it.
synced_profiles = find_synced_profiles(PROFILE_INI)
inactive_profiles = find_inactive_profiles(synced_profiles)
if len(inactive_profiles) is 0:
    sys.exit('All profiles are currently active or unrecoverable. Please close '
            'a profile, manually recover a crashed profile, or create a new '
            'profile with "sync" in the name to open a session.')

# Spawns firefox in a new shell process as libxpcom.so is looked for in the
# wrong directory (/usr/bin/libxpcom.so) with a straight exec call.
first_inactive_profile = inactive_profiles[0]['name']
firefox_cmd = FIREFOX_PATH + ' -P ' + first_inactive_profile
for arg in sys.argv[1:]: firefox_cmd = firefox_cmd + ' ' + arg
print 'bash -c "' + firefox_cmd + '"'
execl(SHELL_PATH, 'bash', '-c', firefox_cmd)
